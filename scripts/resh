#!/usr/bin/env python

from guernsey import Client
from guernsey.filters import *
import atexit, os.path, pprint, readline, subprocess, sys, threading


# ------------------------------------------------------------
# Standard Filter list.
# ------------------------------------------------------------

filters = {'Logging': LoggingFilter(), 'Gzip': GzipContentEncodingFilter(), 'MD5': ContentMd5Filter()}

# ------------------------------------------------------------
# Command-handling functions.
# ------------------------------------------------------------

commands = {}

class AsyncCommandThread(threading.Thread):
    def __init__(self, command, resource, args):
        self.command = command
        self.resource = resource
        self.args = args
        threading.Thread.__init__(self)

    def run(self):
        self.command(self.resource, self.args)

def add_command(cmd, name=None):
    if name is None:
        name = cmd.__name__
    commands[name] = cmd

def command_completer(text, index):
    try:
        return [cmd for cmd in commands.iterkeys() if cmd.startswith(text)][index]
    except IndexError:
        return None

# ------------------------------------------------------------
# Shell commands themselves.
# ------------------------------------------------------------

def cd(resource, path):
    """ cd path
        Resolve path against the current working resource and change
        URL.
    """
    return resource.path(path)
add_command(cd)

def pwd(resource, args):
    """ pwd
        Print current target URL.
    """
    print resource.url
    return resource
add_command(pwd)

def get(resource, args):
    """ get
        Retrieve the current URL entity.
    """
    response = resource.get()
    print str(response.status) + ' ' + response.reason_phrase
    if response.status< 300 and not response.entity is None:
        print response.entity
    return resource
add_command(get)

def head(resource, args):
    """ head
        Retrieve the current resource headers only.
    """
    response = resource.head()
    print str(response.status) + ' ' + response.reason_phrase
    pprint.pprint(response.headers)
    return resource
add_command(head)

def delete(resource, args):
    """ delete
        Delete the current resource.
    """
    response = resource.delete()
    print str(response.status) + ' ' + response.reason_phrase
    return resource
add_command(delete)

def options(resource, args):
    """ options
        Retrieve the options for current resource.
    """
    response = resource.head()
    print str(response.status) + ' ' + response.reason_phrase
    pprint.pprint(response.headers)
    if not response.entity is None:
        print response.entity
    return resource
add_command(options)

def filter(resource, args):
    """ filter [name=On|Off]
        Either display the current status of system filters, or set the
        state of a specific filter.
    """
    if args == '':
        for filter in sorted(filters.keys()):
            if resource.is_filter_present(filters[filter]):
                print '%s is On' % filter
            else:
                print '%s is Off' % filter
    else:
        equals = args.find('=')
        if equals > 0:
            name = args[:equals].strip()
            if name in filters.keys():
                value = args[equals+1:].strip()
                if value == 'On':
                    resource.add_filter(filters[name])
                elif value == 'Off':
                    resource.remove_filter(filters[name])
                else:
                    print 'Must specify either On or Off'
            else:
                print 'Unknown filter: ' + name
        else:
            print 'Try filter name=On|Off'
    return resource
add_command(filter)

def set(resource, args):
    """ set [key=value]
        Either display the current request settings, or define a new request
        setting by providing an HTTP request header key and value.
    """
    if args == '':
        for k in sorted(resource.headers.iterkeys()):
            print '%s=%s' % (k, resource.headers[k])
    else:
        equals = args.find('=')
        if equals > 0:
            # TODO: process variables
            resource.headers[args[:equals].strip()] = args[equals+1:].strip()
    return resource
add_command(set)

def help(resource, args):
    """ help
        Display help on built-in shell commands.
    """
    for cmd in sorted(commands.iterkeys()):
        text = commands[cmd].__doc__
        if text is None:
            print ' ' + cmd
        else:
            print text
    return resource
add_command(help)

def exec_command(resource, args):
    """ ! [command]
        Execute a command in a sub-shell.
    """
    subprocess.call(args, shell=True)
    return resource
add_command(exec_command, "!")

def exit(resource, args):
    """ exit
        Exit the shell.
    """
    return resource
add_command(exit)

# ------------------------------------------------------------
# The following are only shell related functions.
# ------------------------------------------------------------

def configure_readline():
    histfile = os.path.join(os.path.expanduser("~"), ".resh_hist")
    try:
        readline.set_completer(command_completer)
        readline.parse_and_bind("tab: complete")
        readline.parse_and_bind ("bind ^I rl_complete") # OS X hack
        readline.read_history_file(histfile)
        atexit.register(readline.write_history_file, histfile)
    except IOError:
        pass

def parse_command_line(args):
    client = Client.create()
    if len(args) < 1:
        print 'Usage: resh URL'
        sys.exit(1)
    return client.resource(args[0])
 
def parse_rcfile(resource):
    rcfile = os.path.join(os.path.expanduser("~"), ".reshrc")
    if os.path.exists(rcfile):
        file = open(rcfile, 'rt')
        for line in file:
            parse_line(resource, line)
        file.close()

def parse_line(resource, line):
    line = line.strip()
    async = False
    if line.endswith('&'):
        line = line[:line.find('&')].strip()
        async = True
    if line != '':
        space = line.find(' ')
        if space > 0:
            cmd = line[:space]
            line = line[space+1:]
        else:
            cmd = line
            line = ''
        if commands.has_key(cmd):
            if async:
                thread = AsyncCommandThread(commands[cmd], resource.clone(), line)
                thread.start()
            else:
                resource = commands[cmd](resource, line)
        else:
            print 'Unknown command: ' + cmd
    return resource

def run_loop(resource):
    while True:
        try:
            input = raw_input('> ')
            if input.strip() == 'exit':
                break
            resource = parse_line(resource, input)
        except EOFError:
            break

if __name__ == '__main__':
    configure_readline()
    resource = parse_command_line(sys.argv[1:])
    parse_rcfile(resource)
    run_loop(resource)
